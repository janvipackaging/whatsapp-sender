const fs = require('fs');
const path = require('path');
const csv = require('fast-csv');
const { Parser } = require('json2csv');
const Contact = require('../models/Contact');
const Company = require('../models/Company');
const Segment = require('../models/Segment');
const Message = require('../models/Message');
const Campaign = require('../models/Campaign');
const ActivityLog = require('../models/ActivityLog'); 

// --- Helper Function: Auto-fixes phone numbers ---
// UPDATED: Now handles Scientific Notation (E+) and Decimals
function formatPhoneNumber(phone) {
  if (!phone) return null;
  
  let phoneStr = String(phone).trim();

  // 1. Handle Scientific Notation (e.g., "9.18E+11") generated by Excel
  if (phoneStr.toUpperCase().includes('E')) {
    try {
      // Convert scientific to number string (e.g. 919607732123)
      let number = Number(phoneStr);
      phoneStr = number.toLocaleString('fullwide', { useGrouping: false });
    } catch (e) {
      // If conversion fails, keep original to filter out later
    }
  }

  // 2. Remove decimals if any (e.g. "919607.0" -> "919607")
  if (phoneStr.includes('.')) {
    phoneStr = phoneStr.split('.')[0];
  }

  // 3. Clean: Remove all non-numeric characters (spaces, dashes, etc.)
  let cleaned = phoneStr.replace(/[^0-9]/g, '');

  // 4. Validation: If empty after cleaning, return null
  if (!cleaned) return null;

  // 5. Add Prefix: Ensure it starts with +
  return `+${cleaned}`;
}

// @desc    Show the main contacts "Master List" page
exports.getContactsPage = async (req, res) => {
  try {
    const { companyId, segmentId, search } = req.query;

    let query = {};
    if (companyId) {
      query.company = companyId;
    }
    if (segmentId) {
      query.segments = segmentId; // Note: Schema likely uses 'segments' (array) or 'segment' (string). 
                                  // Based on your code it seems to be 'segments' array in populate, 
                                  // but check if your schema uses 'segment' or 'segments'. 
                                  // I will keep your provided logic: query.segments
    }

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } }, 
        { phone: { $regex: search, $options: 'i' } }, 
        { email: { $regex: search, $options: 'i' } }
      ];
    }

    const companies = await Company.find();
    const segments = await Segment.find();
    
    const contacts = await Contact.find(query)
      .populate('company', 'name')
      .populate('segments', 'name')
      .sort({ createdAt: -1 });

    res.render('contacts', {
      user: req.user, // Added user for admin check in EJS
      companies: companies,
      segments: segments,
      contacts: contacts,
      selectedCompany: companyId,
      selectedSegment: segmentId,
      searchTerm: search,
      success_msg: req.flash('success_msg'),
      error_msg: req.flash('error_msg')
    });
  } catch (error) {
    console.error("Error fetching contacts page:", error);
    res.status(500).send('Error loading page');
  }
};

// @desc    Handle the CSV file upload
exports.importContacts = async (req, res) => {
  if (!req.file) {
    req.flash('error_msg', 'No file was uploaded. Please try again.');
    return res.redirect('/contacts');
  }
  const { companyId, segmentId } = req.body;
  if (!companyId || !segmentId) {
    req.flash('error_msg', 'Company and Segment must be selected.');
    return res.redirect('/contacts');
  }

  const contactsToImport = [];
  const filePath = req.file.path; 

  fs.createReadStream(filePath)
    .pipe(csv.parse({ headers: true }))
    .on('error', (error) => {
      console.error(error);
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
      req.flash('error_msg', 'Error parsing CSV file.');
      return res.redirect('/contacts');
    })
    .on('data', (row) => {
      // Map common CSV headers to variables
      const rawPhone = row.phone || row.Phone || row.Mobile || row['Phone 1 - Value'];
      const rawName = row.name || row.Name || row['First Name'];

      // Use the updated Smart Formatter
      const formattedPhone = formatPhoneNumber(rawPhone);
      
      if (formattedPhone && rawName) {
        contactsToImport.push({
          phone: formattedPhone,
          name: rawName,
          company: companyId,
          segments: [segmentId],
          email: row.email || row.Email || null,
          city: row.city || row.City || null,
          productInterest: row.productInterest || null,
          companyName: row.companyName || row.Company || null,
          jobTitle: row.jobTitle || null,
          leadSource: row.leadSource || null,
          leadStatus: row.leadStatus || 'New',
          notes: row.notes || null
        });
      }
    })
    .on('end', async (rowCount) => {
      console.log(`Parsed ${rowCount} rows from CSV.`);
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath); 

      if (contactsToImport.length === 0) {
        req.flash('error_msg', 'No valid contacts with name and phone were found in the file.');
        return res.redirect('/contacts');
      }

      try {
        // ordered: false ensures that if one duplicate fails, the rest still insert
        const result = await Contact.insertMany(contactsToImport, { ordered: false });
        req.flash('success_msg', `Import complete! ${result.length} new contacts were added.`);
        res.redirect('/contacts');
                  
      } catch (error) {
        // Code 11000 = Duplicate Key Error (Phone number already exists)
        if (error.code === 11000 || (error.writeErrors && error.writeErrors.length > 0)) {
           // Calculate how many succeeded
           const insertedCount = error.insertedDocs ? error.insertedDocs.length : (error.result ? error.result.nInserted : 0);
           req.flash('success_msg', `Import finished. ${insertedCount} new contacts added. Duplicates were skipped.`);
           res.redirect('/contacts');
        } else {
          console.error(error);
          req.flash('error_msg', 'An error occurred during database import.');
          res.redirect('/contacts');
        }
      }
    });
};

// @desc    Handle adding a single contact
exports.addSingleContact = async (req, res) => {
  try {
    const { 
      name, phone, companyId, segmentId, 
      email, city, productInterest, companyName, jobTitle, leadSource, leadStatus, notes 
    } = req.body;
    
    if (!name || !phone || !companyId || !segmentId) {
      req.flash('error_msg', 'Name, Phone, Company, and Segment are required.');
      return res.redirect(req.headers.referer || '/'); 
    }

    const formattedPhone = formatPhoneNumber(phone);
    if (!formattedPhone) {
      req.flash('error_msg', 'Invalid phone number format.');
      return res.redirect(req.headers.referer || '/');
    }

    const newContact = new Contact({
      name, phone: formattedPhone, company: companyId, segments: [segmentId],
      email, city, productInterest, companyName, jobTitle, leadSource,
      leadStatus: leadStatus || 'New', notes
    });
    
    await newContact.save();
    
    // Log Activity
    const log = new ActivityLog({
      contact: newContact._id,
      user: req.user._id,
      action: `Contact created and added to segment (Segment ID: ${segmentId})`
    });
    await log.save();
    
    req.flash('success_msg', 'Contact added successfully!');
    res.redirect(req.headers.referer || '/'); 

  } catch (error) {
    console.error('Error adding single contact:', error);
    if (error.code === 11000) {
      req.flash('error_msg', 'Error: A contact with this phone number already exists for this company.');
      return res.redirect(req.headers.referer || '/');
    }
    req.flash('error_msg', 'An error occurred while adding the contact.');
    res.redirect(req.headers.referer || '/');
  }
};

// @desc    Export contacts as a CSV file
exports.exportContacts = async (req, res) => {
  try {
    const { companyId, segmentId, search } = req.query;

    let query = {};
    if (companyId) query.company = companyId;
    if (segmentId) query.segments = segmentId;
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { phone: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } }
      ];
    }

    const contacts = await Contact.find(query).lean(); 

    if (contacts.length === 0) {
      req.flash('error_msg', 'No contacts found in that selection to export.');
      return res.redirect('/contacts');
    }

    const fields = [
      'name', 'phone', 'email', 'city', 'companyName', 
      'jobTitle', 'productInterest', 'leadSource', 'leadStatus', 'notes'
    ];
    const json2csvParser = new Parser({ fields });
    const csv = json2csvParser.parse(contacts);

    res.header('Content-Type', 'text/csv');
    res.attachment('contacts_export.csv'); 
    res.send(csv);

  } catch (error) {
    console.error('Error exporting contacts:', error);
    res.status(500).send('Error exporting contacts');
  }
};

// --- NEW FUNCTION: Clean Bad Contacts (Smart Delete) ---
// This deletes contacts that have 'E+' or '.' in the phone number
exports.cleanBadContacts = async (req, res) => {
  try {
    const { companyId } = req.body;

    if (!companyId) {
      req.flash('error_msg', 'Please select a company to clean.');
      return res.redirect('/contacts');
    }

    // Logic: Find numbers containing "E+" (Scientific) or "." (Decimal)
    // This specifically targets the "9.18E+11" format
    const result = await Contact.deleteMany({
      company: companyId,
      $or: [
        { phone: { $regex: /E\+/ } },  // Contains E+
        { phone: { $regex: /\./ } }    // Contains a dot
      ]
    });

    req.flash('success_msg', `Cleanup Complete! Deleted ${result.deletedCount} invalid contacts.`);
    res.redirect('/contacts');

  } catch (err) {
    console.error(err);
    req.flash('error_msg', 'Error cleaning contacts.');
    res.redirect('/contacts');
  }
};

// @desc    Show the profile page for a single contact
exports.getSingleContactPage = async (req, res) => {
  try {
    const contactId = req.params.id;
    const contact = await Contact.findById(contactId)
      .populate('company', 'name')
      .populate('segments', 'name');

    if (!contact) {
      req.flash('error_msg', 'Contact not found.');
      return res.redirect('/contacts');
    }

    // --- Build Full Activity Log ---
    let logEntries = [];

    // 1. Get all messages
    const messages = await Message.find({ contact: contactId })
      .populate('campaign', 'name')
      .sort({ createdAt: 'asc' });

    messages.forEach(msg => {
      let body = '';
      if (msg.direction === 'inbound') {
        body = `Customer Replied: "${msg.body}"`;
      } else {
        body = `Sent Campaign: "${msg.campaign ? msg.campaign.name : 'Unknown'}" (Status: ${msg.status})`;
      }
      logEntries.push({
        date: msg.createdAt,
        body: body
      });
    });

    // 2. Get all other activity logs
    const activities = await ActivityLog.find({ contact: contactId })
      .populate('user', 'username')
      .sort({ createdAt: 'asc' });

    activities.forEach(act => {
      logEntries.push({
        date: act.createdAt,
        body: `${act.action} by ${act.user ? act.user.username : 'system'}`
      });
    });
    
    // 3. Add Creation event
    logEntries.push({
      date: contact.createdAt,
      body: `Contact Created`
    });

    // 4. Sort
    logEntries.sort((a, b) => b.date - a.date);

    res.render('contact-details', {
      user: req.user,
      contact: contact,
      activityLog: logEntries,
      success_msg: req.flash('success_msg'),
      error_msg: req.flash('error_msg')
    });

  } catch (error) {
    console.error('Error fetching contact details:', error);
    res.status(500).send('Error loading page');
  }
};

// @desc    Handle the "Edit Contact" form submission
exports.updateContact = async (req, res) => {
  try {
    const contactId = req.params.id;
    const updateData = req.body;
    
    if (!updateData.name || !updateData.phone) {
      req.flash('error_msg', 'Name and Phone are required.');
      return res.redirect(`/contacts/view/${contactId}`);
    }
    
    updateData.phone = formatPhoneNumber(updateData.phone);

    // Log Activity for status change
    const oldContact = await Contact.findById(contactId).lean();
    if (oldContact && oldContact.leadStatus !== updateData.leadStatus) {
      const log = new ActivityLog({
        contact: contactId,
        user: req.user._id,
        action: `Lead Status changed from '${oldContact.leadStatus}' to '${updateData.leadStatus}'`
      });
      await log.save();
    }

    await Contact.findByIdAndUpdate(contactId, updateData);

    req.flash('success_msg', 'Contact updated successfully.');
    res.redirect(`/contacts/view/${contactId}`);

  } catch (error) {
    console.error('Error updating contact:', error);
    req.flash('error_msg', 'Error updating contact. Phone number might already exist.');
    res.redirect(`/contacts/view/${req.params.id}`);
  }
};
// --- ADDED MISSING EXPORTS ---
// Since the previous file might have had deleteContact or others, 
// I'll ensure basic CRUD is covered if you need it, 
// but based on your provided file, these are the core functions.
// If you need 'deleteContact' specifically for single delete, let me know.
// For now, this matches your provided structure + the new features.